<p>Skin detection is a very interesting technique with a vivid use case possibility from writing automated
nudity detection scripts to brilliant photographic filters to enhance photographs. Historically it has been
a topic of interests and hence has a lot of work done earlier on the topic. This quick and ugly skin detector using 
canvas (<a href="http://codepen.io/darkyen/pen/ubBHt">demo</a>) was implemented in hurry almost an year ago sitting in the back 
of a JAVA tutorial in college (which i was not so interested in). It uses a basic hypothesis that skin pixels are very
closely present in a specific region inside the HSL Colorspace.</p>

<blockquote>
<p>Please note that this is the most simple and primitive method for skin detection, better methods exist and must be chosen</p>
</blockquote>

<h3>HSL Colorspace</h3>

<h2></h2>

<p>In computers everything is supposed to be a number and hence there are multiple ways to represent a color in a computer,
the most used model being RGB which defines a color as parts of Red, Green and Blue primary colors which can be mixed to obtain
over Sixteen Million Colors. In real world colors are not RGB but instead we percieve colors with a hue its intensity and its brightness
in 1980s computer scientists proposed this new color model which is more logical for humans. The HSL color space defines colors more naturally: Hue specifies the base color, the other two values then let you specify the saturation of that color and how bright the color should be (there exists HSV its close cousin). It is obvious that being close to natural phenomenon this allows us to have more control
and gives a well defined region for skin color (contrary to the RGB colorspace where colors are scattered throughout the spectrum). But computers represent images as RGB Still and so does canvas. Hence we first extract the color values and then convert it to our chosen color-space. This can be simply done using simple mathematics (which turns down to somewhat ugly programming)</p>

<div class="highlight"><pre><code class="javascript"><span class="nx">ImageProcessor</span><span class="p">.</span><span class="nx">toHSV</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">mode</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Fail proofing</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Invalid call&quot;</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">mode</span> <span class="o">===</span> <span class="nx">ImageProcessor</span><span class="p">.</span><span class="nx">color_modes</span><span class="p">.</span><span class="nx">HSV</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Safety check</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Delcare the temporary variables</span>
    <span class="kd">var</span> <span class="nx">w</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span>
        <span class="nx">ht</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">height</span><span class="p">,</span>
        <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nx">h</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span><span class="nx">max</span><span class="p">,</span><span class="nx">min</span><span class="p">,</span><span class="nx">delta</span><span class="p">,</span><span class="nx">r</span><span class="p">,</span><span class="nx">g</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span>
        <span class="nx">pixel</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

    <span class="c1">// Set our buffers color model to HSL</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">mode</span> <span class="o">=</span> <span class="nx">ImageProcessor</span><span class="p">.</span><span class="nx">color_modes</span><span class="p">.</span><span class="nx">HSL</span><span class="p">;</span>


    <span class="k">for</span> <span class="p">(</span><span class="nx">y</span><span class="p">;</span> <span class="nx">y</span> <span class="o">&lt;</span> <span class="nx">ht</span><span class="p">;</span> <span class="nx">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">x</span> <span class="o">&lt;</span> <span class="nx">w</span><span class="p">;</span> <span class="nx">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// For every pixel </span>
            <span class="nx">pixel</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">[</span><span class="nx">y</span><span class="p">][</span><span class="nx">x</span><span class="p">];</span>
            
            <span class="c1">// Find the relative &amp; normalized RGB values</span>
            <span class="nx">r</span> <span class="o">=</span> <span class="nx">pixel</span><span class="p">.</span><span class="nx">R</span> <span class="o">/</span> <span class="mi">255</span><span class="p">;</span>
            <span class="nx">g</span> <span class="o">=</span> <span class="nx">pixel</span><span class="p">.</span><span class="nx">G</span> <span class="o">/</span> <span class="mi">255</span><span class="p">;</span>
            <span class="nx">b</span> <span class="o">=</span> <span class="nx">pixel</span><span class="p">.</span><span class="nx">B</span> <span class="o">/</span> <span class="mi">255</span><span class="p">;</span>

            <span class="c1">// Then find the ma and min of R &amp; G &amp; B in them</span>
            <span class="nx">max</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span><span class="nx">g</span><span class="p">,</span><span class="nx">b</span><span class="p">);</span>
            <span class="nx">min</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span><span class="nx">g</span><span class="p">,</span><span class="nx">b</span><span class="p">);</span>

            <span class="c1">// Find the range</span>
            <span class="nx">delta</span> <span class="o">=</span> <span class="nx">max</span><span class="o">-</span><span class="nx">min</span><span class="p">;</span>

            <span class="c1">//find the S and l</span>

            <span class="c1">// found this formula on wikipedia</span>
            <span class="nx">v</span> <span class="o">=</span> <span class="nx">max</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span> <span class="nx">max</span> <span class="o">!==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">delta</span> <span class="o">!==</span> <span class="mi">0</span><span class="p">){</span>
                <span class="nx">s</span> <span class="o">=</span> <span class="nx">delta</span><span class="o">/</span><span class="nx">max</span><span class="p">;</span>

                <span class="k">if</span><span class="p">(</span> <span class="nx">r</span> <span class="o">===</span> <span class="nx">max</span><span class="p">)</span>
                    <span class="nx">h</span> <span class="o">=</span> <span class="p">((</span><span class="nx">g</span><span class="o">-</span><span class="nx">b</span><span class="p">)</span><span class="o">/</span><span class="nx">delta</span><span class="p">)</span> <span class="o">%</span> <span class="mi">6</span><span class="p">;</span>
                <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="nx">g</span> <span class="o">===</span> <span class="nx">max</span> <span class="p">)</span>
                    <span class="nx">h</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">((</span> <span class="nx">b</span> <span class="o">-</span> <span class="nx">r</span> <span class="p">)</span> <span class="o">/</span> <span class="nx">delta</span><span class="p">);</span>
                <span class="k">else</span>
                    <span class="nx">h</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">((</span> <span class="nx">r</span> <span class="o">-</span> <span class="nx">g</span> <span class="p">)</span> <span class="o">/</span> <span class="nx">delta</span><span class="p">);</span>
                
                <span class="nx">h</span> <span class="o">*=</span> <span class="mi">60</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span> <span class="nx">h</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span>
                    <span class="nx">h</span> <span class="o">+=</span> <span class="mi">360</span><span class="p">;</span>
            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                <span class="nx">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="nx">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
            
            <span class="c1">// set HSV as RGB triplets</span>
            <span class="c1">// Ugly code ... must update !</span>
            <span class="nx">pixel</span><span class="p">.</span><span class="nx">R</span> <span class="o">=</span> <span class="nx">h</span><span class="p">;</span>
            <span class="nx">pixel</span><span class="p">.</span><span class="nx">G</span> <span class="o">=</span> <span class="nx">s</span><span class="p">;</span>
            <span class="nx">pixel</span><span class="p">.</span><span class="nx">B</span> <span class="o">=</span> <span class="nx">v</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>Once we have obtained the HSV values for image, we simply threshold the image for the region we wish
this results in a black and white image because all the pixels not meeting the skin region are turned off
the code performing this is rather simple and hence not discussed.</p>

<h3>Erode and Dilute</h3>

<h2></h2>

<p>Erode and Dilute are two image processing filters, in simple terms erode is a filter which reduces the area
painted in an image. For example imagine a block of 3x3 which is filled with colors upon a pass of erode 
only the pixel whose all surrounding pixels are ON will stay ON rest all the pixels with either of neighbouring
pixel turned OFF will be turned off. Thus erode effectively reduces the region painted. Dilute is the exact opposite
of erode it is used to effectively increase the area painted. By using Erode and Dilute in conjunction we edge off the noise.
The first pass of erode will remove the small noise present and thus only leaving the bigger blobs of detected region ON followed
by the Dilute filter which expands this left area.</p>

<div class="highlight"><pre><code class="javascript"><span class="c1">// Load the image </span>
    <span class="nx">ip2</span><span class="p">.</span><span class="nx">loadImage</span><span class="p">(</span><span class="nx">albert</span><span class="p">);</span>

    <span class="c1">// Extract pixel data out of it</span>
    <span class="nx">mm</span> <span class="o">=</span> <span class="nx">ip2</span><span class="p">.</span><span class="nx">getMap</span><span class="p">();</span>

    <span class="c1">// Convert it to HSV</span>
    <span class="nx">ImageProcessor</span><span class="p">.</span><span class="nx">toHSV</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">mm</span><span class="p">);</span>
    <span class="nx">mm</span><span class="p">.</span><span class="nx">mode</span> <span class="o">=</span> <span class="nx">ImageProcessor</span><span class="p">.</span><span class="nx">color_modes</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">;</span>
    
    <span class="c1">// Call threshold</span>
    <span class="nx">ImageProcessor</span><span class="p">.</span><span class="nx">ThresHold</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">mm</span><span class="p">,{</span>
        <span class="nx">R</span><span class="o">:</span><span class="mi">38</span><span class="p">,</span>
        <span class="nx">G</span><span class="o">:</span><span class="mf">0.68</span>
    <span class="p">},{</span>
        <span class="nx">R</span><span class="o">:</span><span class="mi">6</span><span class="p">,</span>
        <span class="nx">G</span><span class="o">:</span><span class="mf">0.23</span>
    <span class="p">});</span>

    <span class="c1">// Erode 2 pixels</span>
    <span class="nx">ImageProcessor</span><span class="p">.</span><span class="nx">Erode</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">mm</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
    <span class="c1">// Dilute 3 pixels        </span>
    <span class="nx">ImageProcessor</span><span class="p">.</span><span class="nx">Dilute</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">mm</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>

    <span class="c1">// Repaint the generated area</span>
    <span class="nx">ip2</span><span class="p">.</span><span class="nx">setMap</span><span class="p">(</span><span class="nx">mm</span><span class="p">);</span>
    <span class="nx">ip2</span><span class="p">.</span><span class="nx">render</span><span class="p">();</span>

    <span class="c1">// Draw the original image only above the detected region</span>
    <span class="nx">ip2</span><span class="p">.</span><span class="nx">compositePaintImage</span><span class="p">(</span><span class="nx">albert</span><span class="p">,</span><span class="s1">&#39;source-in&#39;</span><span class="p">);</span></code></pre></div>

<h3>Limitations</h3>

<p>Though this technique just works but there are huge limitations to it.</p>

<ul>
<li>Various Skin Colors Need Different hard coding</li>
<li>Color is not a right measure, skin colored walls can confuse the algorithm</li>
</ul>
